/*
 * Alix, A Lucene Indexer for XML documents.
 * 
 * Copyright 2009 Pierre Dittgen <pierre@dittgen.org> 
 *                Frédéric Glorieux <frederic.glorieux@fictif.org>
 * Copyright 2016 Frédéric Glorieux <frederic.glorieux@fictif.org>
 *
 * Alix is a java library to index and search XML text documents
 * with Lucene https://lucene.apache.org/core/
 * including linguistic expertness for French,
 * available under Apache license.
 * 
 * Alix has been started in 2009 under the javacrim project
 * https://sf.net/projects/javacrim/
 * for a java course at Inalco  http://www.er-tim.fr/
 * Alix continues the concepts of SDX under another licence
 * «Système de Documentation XML»
 * 2000-2010  Ministère de la culture et de la communication (France), AJLSM.
 * http://savannah.nongnu.org/projects/sdx/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.oeuvres.alix.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import com.github.oeuvres.alix.maths.Calcul;

/**
 * <p>
 * A specialized table for a dictionary of search, with an int code, an int
 * counter, and an int tag. Conceived for performances, for linguistic usage,
 * but the object do not requires lexical informations. The int code is a way to
 * optimize complex pattern storage (ex: wordgrams). Access possible by a String
 * chain (internal HashMap), or by an int code (internal array, for optimized
 * vector). There are useful methods to get chain list in inverse frequency
 * order.
 * </p>
 * 
 * <p>
 * Each chain added will create an entry or increment a counter if already
 * exists. Int code, generated by an internal autoincrement pointer. It’s a grow
 * only object, entries can’t be removed. There’s no method to put a chain with
 * a free code, search are never replaced and keep their code. Codes are kept
 * consistent during all life of Object.
 * </p>
 * 
 * <p>
 * code » String » [code, counter, tag], access by code need another jump to get
 * the tag.
 * </p>
 * 
 * <p>
 * A String can keep an int tag, set at creation of the entry but is not
 * modified. This could be used to filter dictionary outputs (ex: just
 * substantives, only nouns) with no more lexical informations about the Strings
 * stored. But be careful, this tag is not used as a component for the key. This
 * dictionary do not distinguish homographs by gramcat (same String key,
 * different int tag). The experience shows that a tag is usually not sufficient
 * to distinguish linguistic homography (ex: suis[VERB,être],
 * suis[VERB,suivre].). Better approach is to forge String keys outside from
 * this dictionary (ex: suis,être ; suis,suivre)
 * </p>
 * 
 */
public class DicFreq
{
    /**
     * HashMap to find by String. String is the best object for key (most common,
     * not mutable). A custom object (like Chain) will not match against String. The
     * int array contains an int key and a count
     */
    private HashMap<String, Entry> byTerm = new HashMap<String, Entry>();
    /** List of search, kept in index order, to get a chain by int code */
    private Entry[] byCode = new Entry[32];
    /**
     * Pointer in the array of search, only growing when search are added, used as
     * code
     */
    private int pointer;
    /** Count of all occurrences for this dico */
    private AtomicLong occs = new AtomicLong();
    /** The separator for CSV export and import */
    private static char SEP = ';';

    /**
     * A chain record in the dictionary, obtained by String or by code.
     */
    public class Entry implements Comparable<Entry>
    {
        /** The String form of Chain */
        private final String label;
        /** Internal code for the chain */
        private final int code;
        /** A tag ex gram cat */
        private final int tag;
        /** A counter */
        private AtomicInteger count = new AtomicInteger();
        /** A secondary counter (for comparisons) */
        private AtomicInteger count2 = new AtomicInteger();

        private Entry(final int code, final String label, final int tag) {
            this.code = code;
            this.label = label;
            this.tag = tag;
        }

        public String label()
        {
            return label;
        }

        public int code()
        {
            return code;
        }

        public int tag()
        {
            return tag;
        }

        public int count()
        {
            return count.get();
        }

        public int count2()
        {
            return count2.get();
        }

        /**
         * Is used for debug, is not a save method
         */
        @Override
        public String toString()
        {
            StringBuffer sb = new StringBuffer();
            sb.append(label).append(SEP).append(count).append(SEP).append(code).append(SEP).append(tag).append(SEP)
                    .append(count2);
            return sb.toString();
        }

        @Override
        /**
         * Default comparator for chain informations,
         */
        public int compareTo(Entry o)
        {
            return (o.count.get() + o.count2.get()) - (count.get() + count2.get());
        }
    }

    /**
     * Constructor
     */
    public DicFreq() {
    }

    /**
     * Open a dictionary with a list of search
     * 
     * @param terms
     */
    public DicFreq(final String[] terms) {
        for (String term : terms)
            add(term, 0, 1, 0);
    }

    /**
     * For object reuse, and not too much memory reallocation, reset counters
     * (objects are kept)
     */
    synchronized public void reset()
    {
        occs.set(0);
        pointer = 0;
        byTerm.clear();
    }

    /**
     * Get a chain by code
     * 
     * @param code
     * @return the chain
     */
    public String label(final int code)
    {
        if (code < 1)
            return null;
        if (code > pointer)
            return null;
        return byCode[code].label;
    }

    /**
     * Get the code of a chain, -1 if not found
     * 
     * @param chain
     * @return the key
     */
    public int code(Chain chain)
    {
        @SuppressWarnings("unlikely-arg-type")
        Entry entry = byTerm.get(chain);
        if (entry == null)
            return -1;
        return entry.code;
    }

    /**
     * Get the code of a chain, -1 if not found
     * 
     * @param term
     * @return the key
     */
    public int code(String term)
    {
        Entry line = byTerm.get(term);
        if (line == null)
            return -1;
        return line.code;
    }

    /**
     * Get the tag of a chain, 0 if not found
     * 
     * @param chain
     * @return the key
     */
    public int tag(Chain chain)
    {
        @SuppressWarnings("unlikely-arg-type")
        Entry line = byTerm.get(chain);
        if (line == null)
            return 0;
        return line.tag;
    }

    /**
     * Get the code of a chain, 0 if not found
     * 
     * @param term
     * @return the key
     */
    public int tag(String term)
    {
        Entry line = byTerm.get(term);
        if (line == null)
            return 0;
        return line.tag;
    }

    /**
     * Get the tag of a chain by code, 0 if not found
     * 
     * @param code a chain index
     * @return the state of counter after increments
     */
    public int tag(int code)
    {
        Entry line = byCode[code];
        if (line == null)
            return 0;
        return line.tag;
    }

    /**
     * Get the count for a chain by String, -1 if not found
     * 
     * @param term
     * @return the count of occurrences
     */
    public int count(String term)
    {
        Entry line = byTerm.get(term);
        if (line == null)
            return -1;
        return line.count.get();
    }

    /**
     * Get the count for a chain by Chain (a mutable String), -1 if not found
     * 
     * @param chain
     * @return the count of occurrences
     */
    public int count(Chain chain)
    {
        @SuppressWarnings("unlikely-arg-type")
        Entry line = byTerm.get(chain);
        if (line == null)
            return -1;
        return line.count.get();
    }

    /**
     * Get the count of a chain by code, -1 if not found
     * 
     * @param code a chain index
     * @return the state of counter after increments
     */
    public int count(int code)
    {
        if (code < 1)
            return -1;
        if (code > pointer)
            return -1;
        return byCode[code].count.get();
    }

    /**
     * Increment a chain, set its count at 1, or increment if exists
     * 
     * @param term a word
     * @return the code of chain
     */
    public int inc(final String term)
    {
        Entry entry = byTerm.get(term);
        if (entry == null)
            entry = entry(term, 0);
        entry.count.incrementAndGet();
        occs.incrementAndGet();
        return entry.code;
    }

    /**
     * Increment a chain, or set its counter to 1 if not exists.
     * 
     * @param chain a word
     * @return the code of chain
     */
    public int inc(final Chain chain)
    {
        return inc(chain, 0);
    }

    /**
     * Increment an alternate counter for a chain, or set it to 1 if not exists.
     * 
     * @param term a word
     * @return the code of chain
     */
    public int inc2(final String term)
    {
        return add(term, 0, 0, 1);
    }

    /**
     * Increment an alternate counter for a chain, or set it to 1 if not exists.
     * 
     * @param chain a word
     * @return the code of chain
     */
    public int inc2(final Chain chain)
    {
        return add(chain, 0, 0, 1);
    }

    /**
     * Increment a chain with a tag, or set its counter to 1 if not exists.
     * 
     * @param term a word
     * @param tag  a category code
     * @return the code of chain
     */
    public int inc(final String term, final int tag)
    {
        Entry entry = byTerm.get(term);
        if (entry == null)
            entry = entry(term, tag);
        entry.count.incrementAndGet();
        occs.incrementAndGet();
        return entry.code;
    }

    /**
     * Increment a chain with a tag, or set its counter to 1 if not exists.
     * 
     * @param chain a word
     * @param tag   a category code
     * @return the code of chain
     */
    public int inc(final Chain chain, final int tag)
    {
        @SuppressWarnings("unlikely-arg-type")
        Entry entry = byTerm.get(chain);
        if (entry == null)
            entry = entry(chain.toString(), tag);
        entry.count.incrementAndGet();
        occs.incrementAndGet();
        return entry.code;
    }

    /**
     * Increment an alternate counter for a chain with a tag, or set it to 1 if not
     * exists.
     * 
     * @param term a word
     * @return the code of chain
     */
    public int inc2(final String term, final int tag)
    {
        return add(term, tag, 0, 1);
    }

    /**
     * Increment an alternate counter for a chain, or set it to 1 if not exists.
     * 
     * @param chain a word
     * @return the code of chain
     */
    public int inc2(final Chain chain, final int tag)
    {
        return add(chain, tag, 0, 1);
    }

    /**
     * Add delta to a chain, or set it to delta if not exists.
     * 
     * @param term  a word
     * @param delta add to counter
     * @return the code of chain
     */
    public int add(final String term, final int delta)
    {
        return add(term, 0, delta, 0);
    }

    /**
     * Add delta to a chain, or set it to delta if not exists.
     * 
     * @param chain a word
     * @param delta add to counter
     * @return the code of chain
     */
    public int add(final Chain chain, final int delta)
    {
        return add(chain, 0, delta, 0);
    }

    /**
     * Add delta to a chain with a tag, or set it to delta if not exists.
     * 
     * @param term  a word
     * @param delta add to counter
     * @return the code of chain
     */
    public int add(final String term, final int tag, final int delta)
    {
        return add(term, tag, delta, 0);
    }

    /**
     * Add delta to a chain with a tag, or set it to delta if not exists.
     * 
     * @param chain a word
     * @param delta add to counter
     * @return the code of chain
     */
    public int add(final Chain chain, final int tag, final int delta)
    {
        return add(chain, tag, delta, 0);
    }

    /**
     * Add delta1 and delta2 to the 2 counters of a chain, if not exists create it
     * with a tag and set counters.
     * 
     * @param term
     * @param delta1 for first counter
     * @param delta2 for second counter
     * @return code (old or new)
     */
    public int add(final String term, final int tag, final int delta1, final int delta2)
    {
        Entry entry = entry(term, tag);
        entry.count.addAndGet(delta1);
        entry.count2.addAndGet(delta2);
        occs.addAndGet(delta1);
        occs.addAndGet(delta2);
        return entry.code;
    }

    /**
     * Add delta1 and delta2 to the 2 counters of a chain, if not exists create it
     * with a tag and set counters amounts.
     * 
     * @param chain
     * @param delta1 first count
     * @param delta2 second counter
     * @return code (old or new)
     */
    public int add(final Chain chain, final int tag, final int delta1, final int delta2)
    {
        @SuppressWarnings("unlikely-arg-type")
        Entry entry = byTerm.get(chain);
        if (entry == null) {
            entry = entry(chain.toString(), tag);
        }
        entry.count.addAndGet(delta1);
        entry.count2.addAndGet(delta2);
        occs.addAndGet(delta1);
        occs.addAndGet(delta2);
        return entry.code;
    }

    /**
     * Put a full entry, synchronized method to keep conssitency.
     * 
     * @param chain
     * @param tag
     * @param count
     * @param count2
     * @return
     */
    public int put(final Chain chain, final int tag, final int count, final int count2)
    {
        @SuppressWarnings("unlikely-arg-type")
        Entry entry = byTerm.get(chain);
        if (entry == null) {
            entry = entry(chain.toString(), tag);
        }
        return put(entry, count, count2);
    }

    /**
     * Put a full entry.
     * 
     * @param term
     * @param tag
     * @param count
     * @param count2
     * @return
     */
    public int put(final String term, final int tag, final int count, final int count2)
    {
        Entry entry = entry(term, tag);
        return put(entry, count, count2);
    }

    private int put(Entry entry, final int count, final int count2)
    {
        synchronized (entry) {
            occs.set(occs.get() - entry.count.get() - entry.count2.get() + count + count2);
            entry.count.set(count);
            entry.count2.set(count2);
        }
        return entry.code;
    }

    /**
     * Create a chain if not exists, but do not modify counts.
     * 
     * @param term
     * @return index code
     */
    public int put(final String term)
    {
        return put(term, 0, 0, 0);
    }

    /**
     * Create a chain if not exists, but do not modify counts
     * 
     * @param chain
     * @return index code
     */
    public int put(final Chain chain)
    {
        return put(chain, 0, 0, 0);
    }

    public int put(final Chain chain, final int tag)
    {
        return put(chain, tag, 0, 0);
    }

    public int put(final String term, final int tag)
    {
        return put(term, tag, 0, 0);
    }

    public int put(final Chain chain, final int tag, final int count)
    {
        return put(chain, tag, count, 0);
    }

    public int put(final String term, final int tag, final int count)
    {
        return put(term, tag, count, 0);
    }

    /**
     * Create a chain in the different data structures. Critic fro multiThreading.
     * 
     * @param chain
     * @param tag    An int tag for output filtering
     * @param count  initial value for counter
     * @param count2 initial value for secondary counter
     * @return
     */
    synchronized private Entry entry(final String term, final int tag)
    {
        Entry entry;
        // possible queue, multiple call and entry creation is not finished
        entry = byTerm.get(term);
        if (entry != null) {
            return entry;
        }
        // index is too short, extends it (not a big perf pb)
        if (pointer >= byCode.length) {
            final int oldLength = byCode.length;
            final Entry[] oldData = byCode;
            byCode = new Entry[Calcul.nextSquare(oldLength)];
            System.arraycopy(oldData, 0, byCode, 0, oldLength);
        }
        entry = new Entry(pointer, term, tag);
        // put the same line object by reference in HashMap and Array
        byCode[pointer] = entry;
        pointer++;
        byTerm.put(term, entry);
        return entry;
    }

    /**
     * Size of the dictionary
     */
    public int size()
    {
        return pointer;
    }

    /**
     * Sum of all counts
     */
    public long occs()
    {
        return occs.get();
    }

    /**
     * Increment occurrences count with not stored search (useful for filtered
     * dictionary)
     */
    public DicFreq inc()
    {
        occs.incrementAndGet();
        return this;
    }

    /**
     * Increment occurrences count with not stored search (useful for filtered
     * dictionary)
     */
    public DicFreq add(int delta)
    {
        occs.addAndGet(delta);
        return this;
    }

    /**
     * Return an iterable object to get freqlist
     * 
     * @return
     */
    public List<Entry> byCount()
    {
        List<Entry> list = new ArrayList<Entry>(byTerm.values()); // will copy entries (?)
        Collections.sort(list);
        return list;
    }

    public Entry[] entries()
    {
        return byCode;
    }

    /**
     * To save the dictionary, with some index consistency but… will not works on
     * merge
     * 
     * @param path
     * @throws NumberFormatException
     * @throws IOException           Lucene errors.
     */
    public void csv(Path path) throws IOException
    {
        BufferedWriter writer = Files.newBufferedWriter(path, Charset.forName("UTF-8"));
        csv(writer);
    }

    /**
     * Send a CSV version of the dictionary
     * 
     * @return a CSV string
     */
    public String csv()
    {
        return csv(-1);
    }

    /**
     * Send a CSV version of the dictionary
     * 
     * @param limit
     * @return
     */
    public String csv(int limit)
    {
        StringWriter writer = new StringWriter();
        try {
            csv(writer, limit);
        } catch (Exception e) {
            e.printStackTrace(System.out);
        }
        return writer.toString();
    }

    /**
     * Send a CSV version of the dictionary
     * 
     * @return a CSV string
     */
    /*
     * public String csv( int size, Set<String> stoplist ) { String ret = null; try
     * { ret = csv( new StringWriter(), size, stoplist ).toString(); } catch
     * (IOException e) { e.printStackTrace(); } return ret; }
     */

    /**
     * Give a csv view of all dictionary
     * 
     * @throws IOException Lucene errors.
     */
    public Writer csv(Writer writer) throws IOException
    {
        return csv(writer, -1);
    }

    public void csv(PrintStream stream, int limit) throws IOException
    {
        Writer writer = new PrintWriter(stream);
        csv(writer, limit);
    }

    /**
     * Give a csv view of all dictionary TODO a top filter
     * 
     * @throws IOException Lucene errors.
     */
    public Writer csv(Writer writer, int limit) throws IOException
    {
        // TODO total freqs
        writer.write(
                "(" + occs + ")" + SEP + "COUNT" + SEP + "CODE" + SEP + "TAG" + SEP + "COUNT2" + SEP + "PPM" + "\n");
        try {
            for (Entry entry : byCount()) {
                if (limit-- == 0)
                    break;
                writer.write(entry.toString());
                writer.write(SEP);
                writer.write("" + (double) Math.round(100000000.0 * entry.count.get() / occs.get()) / 100);
                writer.write("\n");
            }
        } finally {
            writer.flush();
        }
        return writer;
    }

    /**
     * DEPRECATED, use a CompDic nstead. Give a csv view of all dictionary
     * 
     * @throws IOException Lucene errors.
     */
    /*
     * public Writer csvcomp( Writer writer, int limit, Set<Chain> stoplist ) throws
     * IOException { String[] byCount = byCount(); int length = byCount.length; int
     * count1; int count2; try { for (int i = 0; i < length; i++) { if (stoplist !=
     * null && stoplist.contains( byCount[i] )) continue; if (limit-- == 0) break;
     * Terminfos values = byTerm.get( byCount[i] ); count1 = values.count; count2 =
     * values.count2; writer.write( byCount[i] +"\t"+ count1 +"\t"+ count2 +"\t"+
     * (count1+count2) +"\t"+NumberFormat.getInstance().format( 1.0*count1 /
     * (count1+count2) ) // +"\t"+index(byCount[i]) +"\n" ); } } finally {
     * writer.close(); } return writer; }
     */

    /**
     * Is used for debug, is not a save method
     */
    @Override
    public String toString()
    {
        StringWriter writer = new StringWriter();
        try {
            csv(writer, 100);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return writer.toString();
    }

    /**
     * Load a freqlist from csv TODO test it
     * 
     * @param path
     * @throws IOException           Lucene errors.
     * @throws NumberFormatException
     */
    public void load(Path path) throws IOException
    {
        BufferedReader reader = Files.newBufferedReader(path, Charset.forName("UTF-8"));
        String line = null;
        int value;
        try {
            // pass first line
            line = reader.readLine();
            while ((line = reader.readLine()) != null) {
                if (line.contains("\t")) {
                    String[] strings = line.split("\t");
                    try {
                        value = Integer.parseInt(strings[1]);
                    } catch (NumberFormatException e) {
                        continue;
                    }
                    add(strings[0].trim(), value);
                } else {
                    inc(line.trim());
                }
            }
        } finally {
            reader.close();
        }
    }

    /**
     * Testing
     * 
     * @throws IOException Lucene errors.
     */
    public static void main(String[] args) throws IOException
    {
        // test synchonisation
        /*
         * BufferedReader buf = new BufferedReader( new
         * InputStreamReader(DicFreq.class.getResourceAsStream("/alix/fr/dic/loc.csv"),
         * StandardCharsets.UTF_8)); String l; DicFreq dic = new DicFreq(); while ((l =
         * buf.readLine()) != null) { if (l.isEmpty()) continue; for (String s :
         * l.split("[ ;]+")) { dic.inc(s); } } dic.csv(new PrintWriter(System.out));
         */
    }
}
